(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, (global.client = global.client || {}, global.client.js = factory()));
})(this, (function () { 'use strict';

  const FunctionComponent = 0; // 函数组件
  const HostRoot = 3; // 挂在的根节点
  const HostComponent = 5; // 原生的html标签 <div>等
  const HostText = 6; // <div>213</div>的 213文本

  const NoFlags = 0b0000000;
  const Placement = 0b0000001;
  const Update = 0b0000010;
  const ChildDeletion = 0b0000100;
  const MutationMask = Placement | Update | ChildDeletion;

  class FiberNode {
      /**
       * @param tag fiber type
       * @param pendingProps those props that will changes
       * @param key ReactElement key
       */
      tag;
      key;
      pendingProps;
      stateNode;
      type;
      ref;
      return;
      sibling;
      child;
      index;
      memoizedProps;
      memoizedState;
      updateQueue;
      alternate;
      flags;
      subTreeFlags;
      constructor(tag, pendingProps, key) {
          // 实例
          this.tag = tag;
          this.key = key;
          // 如果这个fibernode是HostComponent(原生html节点),
          // 那个它的fibernode的stateNode就是改html的dom节点
          this.stateNode = null;
          // 如果该组件是一个functionCompoent, 那么他的tag为0，type为改函数组件本身
          this.type = null;
          // 节点之间关系, 构成树状结构
          // return 代表父fiber节点,react把fiber节点当作一个工作单元
          // 当一个节点完成工作后，会轮到他的父fibernode继续工作
          this.return = null;
          // 右边兄弟节点
          this.sibling = null;
          this.child = null;
          // 表示这个是其父节点的第几个字节点
          this.index = 0;
          this.ref = null;
          // 作为工作单元
          // 这个工作单元刚开始工作的时候 的 props
          this.pendingProps = pendingProps;
          // 工作完后(最终确定下来的props)
          this.memoizedProps = null;
          this.memoizedState = null;
          this.updateQueue = null;
          // 用于指向 另一颗树的FiberNode, 如果是current树的FiberNode,
          // 那么alternate指向workInProgress中对应的FiberNode, 反之亦然
          this.alternate = null;
          // 副作用
          this.flags = NoFlags;
          this.subTreeFlags = NoFlags;
      }
  }
  class FiberRootNode {
      // container保存的是在宿主环境挂载的节点，所以不只是dom节点，浏览器环境中container应该是DOMElement类型
      container;
      current;
      finishedWork; // 更新完成后的 hostRootFiber
      constructor(container, hostRootFiber) {
          this.container = container;
          this.current = hostRootFiber;
          hostRootFiber.stateNode = this;
          this.finishedWork = null;
      }
  }
  const createWorkInProgress = (current, pendingProps) => {
      let wip = current.alternate;
      if (wip == null) {
          // mount
          // 新建一个 wip
          wip = new FiberNode(current.tag, pendingProps, current.key);
          // 继承stateNode
          wip.stateNode = current.stateNode;
          // 通过alternate连接wip和current
          wip.alternate = current;
          current.alternate = wip;
      }
      else {
          // update
          wip.pendingProps = current.pendingProps;
          // cleanup effects
          wip.flags = NoFlags;
          wip.subTreeFlags = NoFlags;
      }
      // 继承type和type,child,memoizedProps和memoizedState
      wip.type = current.type;
      wip.child = current.child;
      wip.memoizedProps = current.memoizedProps;
      wip.memoizedState = current.memoizedState;
      // issue 不要忘记继承current的updateQueue,不然wip到时候没有updateQueue为null,导致计算最新状态时会报错
      wip.updateQueue = current.updateQueue;
      return wip;
  };
  const createFiberFromElement = (element) => {
      const { type, key, props } = element;
      // 先假设tag为FunctionComponent
      let fiberTag = FunctionComponent;
      if (typeof type === "string") {
          // 如果是 hostComponent,那么这个reactElement的type为 html的tag字符串
          fiberTag = HostComponent;
      }
      else if (type !== "function" && true) {
          // 开发时尽量想到边界场景，打印消息方便调试
          console.warn("未定义的类型", element);
      }
      const childFiber = new FiberNode(fiberTag, props, key);
      childFiber.type = type;
      return childFiber;
  };

  const createUpdate = (action) => {
      return {
          action,
      };
  };
  // 定义一个创建updateQueue的方法
  const createUpdateQueue = () => {
      return {
          shared: {
              pending: null,
          },
      };
  };
  // 将update插入updateQueue的方法
  const enqueueUpdate = (updateQueue, update) => {
      updateQueue.shared.pending = update;
  };
  // 消费update的方法
  /**
   * @param baseState state状态
   * @param pendingUpdate update更新
   * @returns {
   *    memoizedState: State;
   *  }
   */
  const processUpdateQueue = (baseState, pendingUpdate) => {
      const result = {
          memoizedState: baseState,
      };
      if (pendingUpdate !== null) {
          if (pendingUpdate.action instanceof Function) {
              result.memoizedState = pendingUpdate.action(baseState);
          }
          else {
              result.memoizedState = pendingUpdate.action;
          }
      }
      return result;
  };

  const supportSymbol = typeof Symbol === "function" && Symbol.for;
  const REACT_ELEMENT_TYPE = supportSymbol
      ? Symbol.for("react.element")
      : 0xfc;

  const ChildReconciler = (shouldTrackEffects) => {
      function placeSingleFiber(fiber) {
          // 当前传入的fiber为才创建的wip fiber,如果alternate为null，说明是首屏渲染
          // 首屏渲染 且 应该追踪副作用的时候 标记副作用
          if (shouldTrackEffects && fiber.alternate === null) {
              fiber.flags |= Placement;
          }
          return fiber;
      }
      // 根据reactElement创建子fiber
      const reconcileSingleElement = (returnFiber, currentFiber, children) => {
          // 根据reactElement创建fiber
          const fiber = createFiberFromElement(children);
          // 创建好子fiber后，与return连接
          fiber.return = returnFiber;
          return fiber;
      };
      // 叶子节点,父节点为原生html标签,传入的content为string或number
      const reconcileSingleTextNode = (returnFiber, currentFiber, content) => {
          // 直接创建HostTextComponent
          const fiber = new FiberNode(HostText, { content }, null);
          // 创建好子fiber后，与return连接
          fiber.return = returnFiber;
          return fiber;
      };
      return function reconcileChildFibers(returnFiber, currentFiber, newChild) {
          // 先判断ReactElementType类型, 对象 还是文本节点
          if (typeof newChild === "object" && newChild !== null) {
              switch (newChild?.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                      return placeSingleFiber(reconcileSingleElement(returnFiber, currentFiber, newChild));
                  default:
                      {
                          console.warn("未实现的reconscile类型", newChild);
                      }
              }
          }
          // TODO: 多节点类型
          if (typeof newChild === "string" || typeof newChild === "number") {
              // updateHostComponent -> ChildReconciler -> reconcileChildFibers
              // 此时newChild的reactElement为字符串或number
              return placeSingleFiber(reconcileSingleTextNode(returnFiber, currentFiber, newChild));
          }
          {
              console.warn("未实现的reconscile类型", newChild);
          }
          return null;
      };
  };
  const reconcileChildFibers = ChildReconciler(true);
  const mountChildFibers = ChildReconciler(false);

  // 递阶段：beginWork
  const beginWork = (fiber) => {
      // 比较 reactElement 和 fiberNode, 生成返回子FiberNode
      // 根据tag进行不同处理
      switch (fiber.tag) {
          case HostRoot:
              return updateHostRoot(fiber);
          case HostComponent:
              return updateHostComponent(fiber);
          case HostText:
              // 没有子节点了 说明已经遍历到叶子节点，开始completeWork
              return null;
          default:
              console.warn("未进行处理的类型");
              break;
      }
  };
  const updateHostRoot = (wip) => {
      // 计算最新状态
      const baseState = wip.memoizedState;
      const pendingUpdate = wip.updateQueue.shared
          .pending;
      const { memoizedState } = processUpdateQueue(baseState, pendingUpdate);
      wip.updateQueue = null; // pendingUpdage = null
      wip.memoizedState = memoizedState;
      const nextChildren = memoizedState;
      // 对比子reactElement和子current fiberNode，生成子wip fiberNode
      reconcileChildren(wip, nextChildren);
      return wip.child;
  };
  const updateHostComponent = (wip) => {
      // <div><span/></div> <span>怎么获取? => <div>.props.children
      // <div>123</div> 子节点的reactElement为hostTextComponent, children为123
      const props = wip.pendingProps;
      const nextChildren = props.children; // props.children可能是 reactElement对象也可能是 字符串或数字
      // 该过程是通过pendingProps的children生成子fiberNode, 如果组件是<div>react</div>那么他的pendingProps.children是react字符串
      // 对比子reactElement和子current fiberNode，生成子wip fiberNode
      reconcileChildren(wip, nextChildren);
      return wip.child;
  };
  const reconcileChildren = (wip, children) => {
      const current = wip.alternate;
      if (current !== null) {
          // update
          // 首屏渲染时，renderRoot中会为hostRootFiber调用createWipFiber方法创建wip fiberNode,
          // 所以hostRootFibe在beginWork时已经有current fiberNode和wip fiberNode了，
          // 在reconcileChildren生成子wip fiber时会走这里,hostRootFiber只会标记一个placement flag,最终会将一整颗离屏dom一次性插入界面
          // hostRootFiber下面的fiber节点会走mountChildFibers
          wip.child = reconcileChildFibers(wip, current.child, children);
      }
      else {
          // mount
          wip.child = mountChildFibers(wip, null, children);
      }
  };

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const createInstance = (type, props) => {
      // TODO: 处理props
      const element = document.createElement(type);
      return element;
  };
  const appendInitialChild = (parent, child) => {
      parent.appendChild(child);
  };
  const createTextInstance = (content) => {
      return document.createTextNode(content);
  };
  const appendChildToContainer = appendInitialChild;

  let nextEffect;
  const commitMutationEffects = (finishedWork) => {
      // 向下遍历，开启外层while循环,找到没有subtreeFlags的节点或是叶子节点
      // 分支语句一: 如果当前节点有child(child !== null)且该节点的subtreeFlags包含MutationMask(nextEffects.subtreeFlags & MutationMask !== NoFlags)
      // 分支语句一的执行命令: nextEffect = nextEffect.child 继续最外层循环
      // 分支语句二: 开启向上遍历,开启内层while循环,调用commitMutationEffectsOnFiber,如果当前节点有sibling,则给nextEffect赋值为其sibling,break内层循环继续外层循环
      //            没有的话一直向上找祖先节点的兄弟节点,直到回到hostRoot停止整个循环,nextEffect.return === null终止整个循环
      nextEffect = finishedWork;
      while (nextEffect !== null) {
          if ((nextEffect.subTreeFlags & MutationMask) !== NoFlags &&
              nextEffect.child !== null) {
              nextEffect = nextEffect.child;
          }
          else {
              // 父节点subtreeFlags包含MutationMask,但是节点本身没有subtreeFlags,说明节点本身有flags
              up: while (nextEffect !== null) {
                  commitMutationEffectsOnFiber(nextEffect);
                  const sibling = nextEffect.sibling;
                  if (sibling !== null) {
                      nextEffect = sibling;
                      break up;
                  }
                  else {
                      nextEffect = nextEffect.return;
                  }
              }
          }
      }
  };
  function commitMutationEffectsOnFiber(finishedWork) {
      // finishedWork是本身包含flags的fiberNode
      const flags = finishedWork.flags;
      if ((flags & Placement) !== NoFlags) {
          commitPlacement(finishedWork);
          // 执行placement操作后,消除placement的flag
          finishedWork.flags &= ~Placement;
      }
  }
  function commitPlacement(finishedWork) {
      {
          console.warn("执行placement操作", finishedWork);
      }
      // 插入操作需要两个变量: parent的dom, finishedWork对应的dom
      const hostParent = getHostParent(finishedWork);
      if (hostParent !== null) {
          // 然后将finishedWork对应的dom插入parent的dom, appendPlacementNodeIntoContainer
          appendPlacementNodeIntoContainer(finishedWork, hostParent);
      }
  }
  function getHostParent(fiber) {
      let parent = fiber.return;
      while (parent !== null) {
          const tag = parent.tag;
          if (tag === HostComponent) {
              return parent.stateNode;
          }
          else if (tag === HostRoot) {
              return parent.stateNode.container;
          }
          parent = parent.return;
      }
      {
          console.warn("未找到parent dom");
      }
      return null;
  }
  function appendPlacementNodeIntoContainer(finishedWork, hostParent) {
      // 传进来的finishedWork不一定就是hostComponent或者hostText,所以要向下遍历找到对应的host节点
      if (finishedWork.tag === HostComponent || finishedWork.tag === HostText) {
          // 该方法与宿主有关，先放到hostConfig.ts中
          appendChildToContainer(hostParent, finishedWork.stateNode);
      }
      const child = finishedWork.child;
      if (child !== null) {
          appendPlacementNodeIntoContainer(child, hostParent);
          let sibling = child.sibling;
          while (sibling !== null) {
              appendPlacementNodeIntoContainer(sibling, hostParent);
              sibling = sibling.sibling;
          }
      }
  }

  const completeWork = (wip) => {
      const newProps = wip.pendingProps;
      const current = wip.alternate;
      // 归阶段
      // 根据tag对fiber进行不同操作
      // hostComponent 创建dom实例, 然后将下一层所有子fiber对应的dom插入parent中
      // hostRoot收集下一层所有子fiber的flags
      switch (wip.tag) {
          case HostRoot:
              bubbleProperties(wip);
              return null;
          case HostComponent:
              // current === null时，才是mount阶段
              if (current === null) {
                  // mount
                  // 构建dom 这一步不一定生成浏览器中的dom节点，和宿主环境有关
                  const instance = createInstance(wip.type);
                  // 将dom插入dom树中
                  appendAllChildren(instance, wip);
                  // 当前处于归的阶段,当前dom树是目前最靠上的dom节点
                  wip.stateNode = instance;
              }
              bubbleProperties(wip);
              return null;
          case HostText:
              if (current === null) {
                  // mount
                  const instance = createTextInstance(newProps.content);
                  // hostText没有child所以不需要appendAllChildren
                  wip.stateNode = instance;
              }
              bubbleProperties(wip);
              return null;
          default:
              {
                  console.warn("未执行的类型", wip.tag);
              }
      }
      return null;
  };
  // function A(){return <span>hello</span>}
  // <B><A/></B> 如果父节点只有一个字节点的话，只需要直接插入字节点对应的stateNode
  // <B>react<A/><A/></B> 多个字节点的话，对于子节点来说，还需要插入兄弟节点
  // 将该节点下面所有子dom插入fiber中,因为fiber和dom节点不是一一对应的，所以要判断tag拿到dom节点
  const appendAllChildren = (parent, wip) => {
      let node = wip.child;
      while (node != null) {
          // 第一步，首先向下遍历到第一层dom节点, HostComponent和HostText就插入到父节点,
          // 其他类型节点如functionComponent就接着向下遍历子节点，将下面第一层HostComponent和HostText类型的子节点插入父节点
          if (node.tag === HostComponent || node.tag === HostText) {
              // 特定的功能建议写成一个方法, 这样可以不耽误大概逻辑, 代码也会变得易读简洁,方法也方便管理
              appendInitialChild(parent, node?.stateNode);
          }
          else if (node.child !== null) {
              // 如果node不是hostRoot或者hostComponent,可以查看它的子节点
              node.child.return = node; // 建立节点之间的连接
              node = node.child;
              continue;
          }
          // 终止情况: 因为completeWork有一个归阶段，会往上遍历，如果走到当前wip，便停止while循环
          if (node == wip) {
              return;
          }
          // 到此，当前节点是hostComponent或hostText节点，或者是没有child的叶子节点了,轮到遍历到兄弟节点了
          // 第二步: 先判断有没有兄弟节点时，没有的话,则会往上,找祖先节点的兄弟节点
          // 一直往上找祖先节点的sibling的节点，跳过没有sibling的祖先节点，
          // 有两种可能,找到祖先节点的sibling重新开始大循环, 没有祖先sibling了，直到node.return === null || node === wip,整个循环停止
          while (node.sibling === null) {
              // 终止情况: 当回到hostRoot或原点时终止遍历
              if (node.return === null || node === wip) {
                  return;
              }
              // 向上遍历
              node = node.return;
          }
          // node赋值为sibling,开始收集兄弟节点的dom
          node.sibling.return = node.return; // 建立连接
          node = node.sibling;
      }
  };
  // flags散落在不同各个fiber节点，怎么快速找到他们?
  // 可以利用completeWork向上遍历阶段可以将子fiber的flags一层一层冒泡到父fiber节点
  // 给fiberNode添加一个subtreeFlags保存子fiber的flags
  function bubbleProperties(wip) {
      let subtreeFlags = NoFlags;
      let child = wip.child;
      while (child !== null) {
          // 收集子节点和其后代节点上的flags
          subtreeFlags |= child.subTreeFlags;
          subtreeFlags |= child.flags;
          child.return = wip;
          child = child.sibling;
      }
      wip.subTreeFlags |= subtreeFlags;
  }

  // 整体递归流程
  // 全局的指针 指向当前FiberNode节点
  let workInProgress = null;
  const scheduleUpdateOnFiber = (hostRootFiber) => {
      // TODO: 任务调度
      // 更新可能发生在任意fiberNode,找到FiberRootNode根节点
      const root = markUpdateFromFiberRoot(hostRootFiber);
      renderRoot(root);
  };
  const markUpdateFromFiberRoot = (fiber) => {
      while (fiber.return) {
          fiber = fiber.return;
      }
      if (fiber.tag === HostRoot) {
          return fiber.stateNode;
      }
      return null;
  };
  function prepareFreshStack(root) {
      // FiberRootNode 不能直接当作workInProgress,需要调用创建wip的方法
      workInProgress = createWorkInProgress(root.current, {});
  }
  // 最终执行的方法叫 renderRoot,参数是一个特殊FiberNode: FiberRootNode
  function renderRoot(root) {
      // 初始化，让workInProgress指向第一个遍历的FiberNode
      prepareFreshStack(root);
      // 开始遍历
      do {
          try {
              workLoop();
              break;
          }
          catch (err) {
              {
                  console.log("sth went wrong when runing workloop");
              }
              workInProgress = null;
          }
      } while (true);
      // workLoop完成后,一颗完成的wip fiberTree已经生成, 就是一开始通过createWorkInProgress(root.current, {})创建的fiberNode,
      // 此时它已经拥有完整的子节点，并且包含了所以子节点的flags-subTreeFlags
      const finishedWork = root.current.alternate;
      root.finishedWork = finishedWork;
      // wip fiberTree构建完成后,开始commit阶段
      commitRoot(root);
  }
  function commitRoot(root) {
      const finishedWork = root.finishedWork;
      if (finishedWork === null) {
          // 排除异常参数
          return;
      }
      // 重置root.finishedWork
      root.finishedWork = null;
      // 判断root.current.alternate(hostRoot.wip)和自身和子节点是否存在flags
      const subtreeHasEffect = (finishedWork.subTreeFlags & MutationMask) !== NoFlags;
      const rootHostEffect = (finishedWork.flags & MutationMask) !== NoFlags;
      if (subtreeHasEffect || rootHostEffect) {
          // beforeMutation
          // mutation
          commitMutationEffects(finishedWork);
          // fiber树切换发生在 mutation 和 layout阶段之间
          root.current = finishedWork;
          // layout
      }
      else {
          root.current = finishedWork;
      }
  }
  // 开启遍历，每次循环就是一次工作，由performUnitOfWork执行
  function workLoop() {
      while (workInProgress != null) {
          performUnitOfWork(workInProgress);
      }
  }
  function performUnitOfWork(fiber) {
      // beginWork 比较ReactElement 与fiberNode,生成子fiberNode
      const next = beginWork(fiber);
      fiber.memoizedProps = fiber.pendingProps;
      // 如果next有值，说明有子fiberNode，按照深度优先遍历原则，开始遍历其子节点
      // 如果没有返回子节点了，说明已经遍历到最深处，开始归阶段
      if (next == null) {
          completeUnitOfWork(fiber);
      }
      else {
          workInProgress = next;
          // 当workInProgress有值时，workLoop会接着调用performUnitOfWork 进行递阶段，直到遍历到最深层
      }
  }
  function completeUnitOfWork(fiber) {
      let node = fiber;
      // 首先该节点先进行completeWork
      // 此时该fiberNode已经在归阶段：有兄弟节点，右边兄弟节点进入递阶段，没有的话，进入父节点的归阶段
      // 一直遍历兄弟节点执行completeWork，最后进入父节点的归阶段
      do {
          //issue 这里是传node，不是fiber,不然一直都是对hostText的completeWork
          completeWork(node);
          const sibling = node.sibling;
          if (sibling !== null) {
              // 兄弟节点进入递阶段
              workInProgress = sibling;
              return;
          }
          node = node.return;
          workInProgress = node;
      } while (node !== null);
  }

  // 在执行React.CreateRoot方法时，内部会调用createContainer
  const createContainer = (container) => {
      // 创建hostRootFiber节点(宿主环境挂载节点对应的fiberNode) 参数: tag,pendeingProps,key
      const hostRootFiber = new FiberNode(HostRoot, {}, null);
      // 创建fiberRootNode 参数: container, hostRootFiber
      const root = new FiberRootNode(container, hostRootFiber);
      // 给hostRootFiber创建一个updateQueue与更新机制对接
      hostRootFiber.updateQueue = createUpdateQueue();
      console.log(hostRootFiber, "createContainer hostRootFiber");
      return root;
  };
  // 在执行root.render(<App/>)时，内部会调用updateContainer
  const updateContainer = (reactElement, root) => {
      const hostRootFiber = root.current;
      const update = createUpdate(reactElement);
      enqueueUpdate(hostRootFiber.updateQueue, update);
      scheduleUpdateOnFiber(hostRootFiber);
      return reactElement;
  };

  // ReactDom.createRoot(dom).render(<App/>)
  const createRoot = (element) => {
      const root = createContainer(element);
      return {
          render(element) {
              updateContainer(element, root);
          },
      };
  };

  var ReactDom = /*#__PURE__*/Object.freeze({
    __proto__: null,
    createRoot: createRoot
  });

  return ReactDom;

}));
